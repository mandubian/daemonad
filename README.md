# Daemonad: snoop in your monad stacks with Scala macros

`Daemonad` is a nasty Scala macro that aims at:

- marking where you manipulate monads or stacks of monads
- compile-checking monadic behavior & implicit monad instances
- allowing to `snoop` monad values in the same way as `ScalaAsync` i.e. in a pseudo-imperative way.

> This project is NOT yet stable, NOT very robust so use it at your own risks.

<br/>
## Here is what id does

Finally, here is what you can write right now.

```scala
Await.result(
  monadic[Future, List, Option] {
    val a = Future ( Some(9) )
    val b = Some(7)
    val c = 10
    if(snoop2(a) < 10) snoop1(b) + 10
    else c
  }, duration.Duration("1 second")
) should equal (Some(17))
```

<br/>
## Motivations

### 1 - Experiment writing a very ugly Scala macro

I wanted to write a huge & complex Scala macro to know the difficulties that it implies.

> Result: I was quite insane and I will certainly write a post-mortem article about it to show the horrible difficulties I've encountered.

<br/>
### 2 - Investigate ScalaAsync generalization to all monads + (some) monad stacks

I had investigated [ScalaAsync](https://github.com/scala/async) code and thought it would be possible to generalize it to all kinds of monads and go further by managing monad stacks.

> Result : Simple monads are easy to manage (as seen also in [scala-workflow](https://github.com/aztek/scala-workflow) which I discovered very recently) and some monad stacks can be managed with Scalaz monad transformers.
> But don't think you can use all kinds of monad transformers: the limits of Scala compiler with type-lambdas in macros and my very own limits blocked me from going as far as I expected.
> So for now, it can manage Future/Option/List stacks & also \/ using type aliases.

<br/>
### 3 - Mark monadic blocks

There are 2 ways of seeing monads:

1. You don't need or you don't want to know what is a monad...

... Yet you use it everyday/everywhere.

This is what most of us do using those cool `map/flatMap` functions provided by Scala libraries that allow to access the values inside `Future`, `List`, `Option` in a _protected_ way etc...
That's enough for you need in your everyday life, right?


2. You want to know or you know what is a monad ...

... You want to use them on purpose.

This is what _hippy developers_ do in advanced Scala using Scalaz or even crazier in pure FP languages like Haskell.

> Guess what I prefer?

Here is the kind of code I'd like to write :

```scala
// I write my datastructure without any map/flatMap function
case class Toto[A](a: A)

// Hey I proved Toto was a monad (yes believe me)

// Let's bring this concept into my scope
implicit object TotoMonad extends Monad[Toto] {
  def bind[A, B](fa: Toto[A])(f: A => Toto[B]): Toto[B] = {
    f(fa.a)
  }

  def point[A](a: => A): Toto[A] = Toto(a)
}

...
// I create my toto
val toto = Toto("this is toto")

...

// Suddenly I decide that I must use this monadic behavior of toto
val toto2: Toto[String] = monadic[Toto] {
  val a = <snoop_value_inside_monad>(toto) // outside the monadic block, you shall not do that
  do_something_with_value(a)
  // The compiler takes care that my structure is used in a pure monadic way
}
...
```

> Ok I speak about pure functional programming and then about snooping the value out of the monad. This might seem a bit useless or even stupid compared to using directly Monad facilities. I agree and I still wonder about the sanity of this project but I'm stubborn and I try to finish what I start ;)


<br/>
## Back to code Sample

```scala
Await.result(
  monadic[Future, List, Option] {
    val a = Future ( Some(9) )
    val b = Some(7)
    val c = 10
    if(snoop2(a) < 10) snoop2(b) + 10
    else c
  }, duration.Duration("1 second")
) should equal (Some(17))
```

- `monadic` marks the monadic block
- `monadic[Future, List, Option]` declares that you manipulate a stack `Future[List[Option]]` (and no other)
- `snoopX` means that you want to snoop the monad value at X-th level (1, 2, 3, 4 and no more yet)
- checks for implicit instances of monads (here `List`, `Option`, `Future`) and monad transformers (here `OptionT` & `ListT`) for this stack
- translating this code into embedded `Monad.bind/point/lift/run`...

I'm sure you don't want to see the code you would have to write for this, this is quite long and boring.

Let just say that this code is generated by a Scala macro that:


> The current generated code isn't optimized at all but this is for next iterations.

## What isn't working ?

- many things or edge-cases with mixed monad depth and if/match.
- can't use advanced monad transformers like StateT or WriterT in monadic block because Scala compiler doesn't allow what I expected with type lambdas. _This needs to be studied further._

<br/>
## TODO

- refactor all code because it's ugly, not robust and redundant!!!
- rely on `MonadTrans[F[_], _]` instead of hardcoding monad transformers as now.
- accept custom `MonadTrans` provided in the user code.
- steal some inspiration from [scala-workflow](https://github.com/aztek/scala-workflow) because I find this code cool.

